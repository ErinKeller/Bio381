---
title: "Shiny Tutorial"
author: "Erin Keller"
date: "April 23, 2017"
output: html_document
runtime: shiny
---

## What are Shiny Apps?
Shiny apps are webpages (html) that allow users to interact with R code without having to code themselves. In essence, Shiny apps allow the user to manipulate inputs (variables) and observe the changes to the output(s) (graphs, tables, etc.); this works by having an open R script on a server (privately hosted from the owner's computer or ShinyApps.io) that reruns its code to reflect changes to its inputs by a user on the webpage. 

To get an idea of the reactivity of Shiny, copy and paste the code below and run the script. This will generate a webpage that the user (you!) can manipulate.
```{r}
library(shiny)
ui <- fluidPage(
  sliderInput(inputId= "num",
              label = "Choose a number",
              value = 25, min = 1, max = 100),
  plotOutput("hist"))

server <- function(input, output) {
  output$hist <- renderPlot({
    title <- "100 random normal values"
    hist(rnorm(input$num), main= title)})
    }

shinyApp(ui = ui, server = server)
```

## The basics
Shiny requires two things to make a Shiny app; these are the ui code which contains the components needed to make your app (aesthetics, layout, input options) and the server code which contains the script that takes the supplied inputs and generates the desired output (graphs, tables, text, etc.). 

### The ui
The ui is the interactive part of the script that deals with primarily with the input(s) and design of the webpage. This will end up being the part of the script that enables users to manipulate input variables. Your input variables can take on many different forms including sliders, drop down menus, buttons, etc. (for complete list of input functions see [Shiny's reference page](https://shiny.rstudio.com/reference/shiny/latest/)). 

![](InputOptions.jpg)

Each input function has the same basic syntax. For example:
sliderInput(inputId = "num", label = "Choose a number", ...)

* **inputId** specifies the name of the input
* **label** allows you to enter a description for your input. This is optional, if you do not want to write anything, just write: label = ""
* **input specific arguments** vary among different input options. These arguments include number ranges, means, starting values, etc. for your input to take

The ui also requires an output function. These specify what type of output is desired and can be plots, graphs, text, tables, etc. and makes space on your webpage for this type of output. Like inputs, outputs also have similar syntax, for example:

plotOutput(outputId = "hist", ...)

* **outputId** specifies the name of the output
* **output specific arguments** vary among different output options (i.e. graph labels, colors, etc.)



![](OutputOptions.jpg)

### The server
The server contains the code needed to convert the inputs into the desired output. There are three rules to building the server:

#### 1.
Save object to display to output$* where the asterisk is the element to be placed in the output 

#### 2) 
Build objects to display with render* where the asterisk is the type of object you want to display. For most of the render functions there is a input function analogue. Below are examples of the different render options.
![](RenderOptions.jpg)

Render functions also have consistent syntax:

renderPlot({hist(rnorm(500))})

where inside the curley brackets is the block of R code to convert the input into the output. There is no limit to the amount of code you can put into this part. 

#### 3. 
Use input values with input$ in the server part of your script. This allows you to access the reactive input value that the user sets to include in the output script. 


## Let's start making a Shiny App!

### It's easiest to start with a Shiny App template
This template contains the minimum elements needed for a Shiny app. Try running the template code below. Nothing will show up because we haven't added any elements but running this code does produce an empty app. 
```{r}
library(shiny)
ui <- fluidPage()

server <- function(input, output) {
  
    }

shinyApp(ui = ui, server = server)
```

### Basic example with one input and one output:
```{r}
library(shiny)
ui <- fluidPage(
  selectInput(inputId= "num", # unlike the first example of a histogram of random numbers, we can use a drop-down menu rather than a slider. Easy fix by replacing sliderInput with selectInput and change values to choices
              label = "Choose a number",
              choices = c(10,20,30,40,50,60,70,80,90,100)), # choices reflect what values the user can select
  plotOutput("hist"))

server <- function(input, output) {
  output$hist <- renderPlot({
    title <- "random normal values"
    hist(rnorm(input$num), main= title)})
    }

shinyApp(ui = ui, server = server)
```



### We can also also have Shiny apps with multiple inputs and/or outputs:
```{r}
library(shiny)

ui <- fluidPage(
  sliderInput(inputId = "num", 
    label = "Choose a number", 
    value = 25, min = 1, max = 100),
  textInput(inputId = "title",  # textInput allows the user to write something that is incorporated into the output, in this case, the user can add a title
    label = "Write a title",
    value = "Histogram of Random Normal Values"), # value signifies what the starting value will be
  actionButton(inputId = "button", label = "Update"), # adding an action button allows the user to manipulate the inputs and have the app only react when you select the action button
  plotOutput("hist")
)

server <- function(input, output) {
  output$hist <- renderPlot({
    input$button # specify that there is an action button so the code knows now to update when inputs are changed until the action button is selected
    hist <- isolate(hist(rnorm(input$num), main = input$title)) # we can use the input element we created in the ui and call that in the code to generate a title
  })
}

shinyApp(ui = ui, server = server)
```

### Now let's make a Shiny app for Hardy-Weinberg Equilbrium
For this app, the user can select the observed number of individuals for three genoytpes, AA, AB, or BB. Based on the observed genotype counts, the app will determine if the population is in Hardy-Weinberg Equilibrium using a Chi-Squared test.

```{r}
# HWE

library(shiny)
# using sliderInput to allow the user to select the observed counts for each genotype
ui <- fluidPage(sliderInput(inputId = "AA", 
                            label = "Choose a number of observed AA individuals", # this is what will be displayed above the slider
                            value = 500, min = 0, max = 1000),
                sliderInput(inputId = "AB", 
                            label = "Choose a number of observed AB individuals", 
                            value = 500, min = 0, max = 1000),
                sliderInput(inputId = "BB", 
                            label = "Choose a number of observed BB individuals", 
                            value = 500, min = 0, max = 1000),
                textOutput("signif")) # the output will be a direct copy of the output from the Chi-Squared test stored in signif

server <- function(input, output) {
  
  observe({ # observe is an observer function that tells the server to rerun the entire script when input values are changed
    N <-sum(input$AA,input$AB,input$BB) # calculating the total population size
    p <- (input$AA+(0.5*input$AB))/N # generating p and q frequencies
    q <- 1 - p
    ObsN <- c(input$AA,input$AB,input$BB) # making a vector of the observed counts for each genotype
    ExpAA <- (p^2)*N # calculating the expected counts for each genotype
    ExpAB <- 2*p*q*N
    ExpBB <- (q^2)*N
    ExpN <- c(ExpAA,ExpAB,ExpBB) # creatin a vector of the expected counts for each genotype
    matrix <- cbind(ObsN,ExpN) # generating a matrix of the expected and observed
    signif <- chisq.test(matrix,matrix,correct=TRUE) # determining significance using chisq.test
    output$signif <- renderPrint({print(signif)}) # use renderPrint to tell the code that the printed results of signif are what is to be displayed
  })
              
}

shinyApp(ui = ui, server = server)
```

## Up until this point we have been hosting the apps on our own computers, but we can also publish the app for the public to see!

We can do this by setting up an account at [shinyapps.io](shinyapps.io). 

Take a look at a more refined version of the Hardy Weinberg app I created and published  [here](https://erinlkeller.shinyapps.io/hardy-weinberg_equilibrium/).

## Benefits and Limitations to Shiny
### Benefits
* free to use and share!
* developed by RStudio 
* extremely well documented (2.5 hour tutorial!)
* no knowledge of html needed
* for the most part the code is regular R code
* great resource for teaching or presentations, other people could even redo your analysis!

### Limitations
* sharing your app using shinyapps.io is only free if there is minimal traffic (after that you can pay for Shiny Apps Pro)
* Every time you run your app you need to close it or terminate the run before you can update it
* steep learning curve and while the tutorial was really comprehensive, it did gloss over some important information that is required to successfully run the app

## Want to learn Shiny?
Click [here](https://shiny.rstudio.com/tutorial/) to begin the tutorial!


